### 数组转置和轴对称

```python
import numpy as np
arr = np.arange(15).reshape((3,5))
arr
>>>array([[ 0,  1,  2,  3,  4],
       [ 5,  6,  7,  8,  9],
       [10, 11, 12, 13, 14]])

arr.T
>>>array([[ 0,  5, 10],
       [ 1,  6, 11],
       [ 2,  7, 12],
       [ 3,  8, 13],
       [ 4,  9, 14]])
```

```python
arr = np.random.randn(6,3)
np.dot(arr.T,arr)
>>>array([[ 8.02959867, -3.01630352, -0.41965466],
       [-3.01630352,  2.5214298 , -0.46033103],
       [-0.41965466, -0.46033103, 10.16008764]])
```

```python
arr = np.arange(16).reshape((2,2,4))
arr
>>>array([[[ 0,  1,  2,  3],
        [ 4,  5,  6,  7]],

       [[ 8,  9, 10, 11],
        [12, 13, 14, 15]]])

arr.transpose((1,0,2))
>>>array([[[ 0,  1,  2,  3],
        [ 8,  9, 10, 11]],

       [[ 4,  5,  6,  7],
        [12, 13, 14, 15]]])

arr
>>>array([[[ 0,  1,  2,  3],
        [ 4,  5,  6,  7]],

       [[ 8,  9, 10, 11],
        [12, 13, 14, 15]]])

arr.swapaxes(1,2)
>>>array([[[ 0,  4],
        [ 1,  5],
        [ 2,  6],
        [ 3,  7]],

       [[ 8, 12],
        [ 9, 13],
        [10, 14],
        [11, 15]]])

# arr.transpose(0,2,1)
```



### sqrt/exp

```python
arr = np.arange(10)
np.sqrt(arr)
>>>array([0.        , 1.        , 1.41421356, 1.73205081, 2.        ,
       2.23606798, 2.44948974, 2.64575131, 2.82842712, 3.        ])

np.exp(arr)
>>>array([1.00000000e+00, 2.71828183e+00, 7.38905610e+00, 2.00855369e+01,
       5.45981500e+01, 1.48413159e+02, 4.03428793e+02, 1.09663316e+03,
       2.98095799e+03, 8.10308393e+03])
```



### random/maxium

```python
x = np.random.randn(8)
y = np.random.randn(8)
x
>>>array([-0.04595981, -2.15861556, -0.08358151, -1.48131722, -0.37872425,
       -1.48837647, -0.22262516, -0.12835625])

y
>>>array([ 0.9594706 , -1.0880696 ,  0.8008791 ,  2.0004324 , -0.27211227,
       -1.11686688,  0.32534689,  0.6895263 ])

np.maximum(x,y)
>>>array([ 0.9594706 , -1.0880696 ,  0.8008791 ,  2.0004324 , -0.27211227,
       -1.11686688,  0.32534689,  0.6895263 ])

arr = np.random.randn(7) * 5
np.modf(arr) # 小数和整数部分分开独立返回
>>>(array([ 0.02224907, -0.20253028,  0.02301522, -0.9997869 , -0.41497456,
         0.67363257,  0.38851297]), array([ 4., -7.,  1., -0., -1.,  5.,  5.]))
```



### 进行数据处理的方式

```python
import numpy as np
points = np.arange(-5,5,0.01) # 1000个间隔相等的点
xs,ys = np.meshgrid(points,points)
ys
>>>array([[-5.  , -5.  , -5.  , ..., -5.  , -5.  , -5.  ],
       [-4.99, -4.99, -4.99, ..., -4.99, -4.99, -4.99],
       [-4.98, -4.98, -4.98, ..., -4.98, -4.98, -4.98],
       ...,
       [ 4.97,  4.97,  4.97, ...,  4.97,  4.97,  4.97],
       [ 4.98,  4.98,  4.98, ...,  4.98,  4.98,  4.98],
       [ 4.99,  4.99,  4.99, ...,  4.99,  4.99,  4.99]])

import matplotlib.pyplot as plt
z = np.sqrt(xs ** 2 + ys ** 2)
z
>>>array([[7.07106781, 7.06400028, 7.05693985, ..., 7.04988652, 7.05693985,
        7.06400028],
       [7.06400028, 7.05692568, 7.04985815, ..., 7.04279774, 7.04985815,
        7.05692568],
       [7.05693985, 7.04985815, 7.04278354, ..., 7.03571603, 7.04278354,
        7.04985815],
       ...,
       [7.04988652, 7.04279774, 7.03571603, ..., 7.0286414 , 7.03571603,
        7.04279774],
       [7.05693985, 7.04985815, 7.04278354, ..., 7.03571603, 7.04278354,
        7.04985815],
       [7.06400028, 7.05692568, 7.04985815, ..., 7.04279774, 7.04985815,
        7.05692568]])
# %%
plt.imshow(z,cmap=plt.cm.gray)
plt.colorbar()
# %%
```



### where函数

```python
xarr = np.array([1.1,1.2,1.3,1.4,1.5])
yarr = np.array([2.1,2.2,2.3,2.4,2.5])
cond = np.array([True,False,True,True,False])
result = [(x if c else y) for x,y,c in zip(xarr,yarr,cond)]
result
>>>[1.1, 2.2, 1.3, 1.4, 2.5]

result = np.where(cond,xarr,yarr)
result
>>>array([1.1, 2.2, 1.3, 1.4, 2.5])
```

```python
arr = np.random.randn(4,4)
arr
>>>array([[-0.97191715,  0.34417757,  0.77529307, -0.65098348],
       [-1.32488361,  0.1066985 , -0.61540483, -0.58295264],
       [-2.44526354,  1.00357494,  0.23797779, -1.73224649],
       [-0.34215509, -1.07049879, -0.28219591, -0.3031155 ]])

np.where(arr>0,2,-2) #2 if >0 else -2
>>>array([[-2,  2,  2, -2],
       [-2,  2, -2, -2],
       [-2,  2,  2, -2],
       [-2, -2, -2, -2]])

np.where(arr > 0,2,arr)
>>>array([[-0.97191715,  2.        ,  2.        , -0.65098348],
       [-1.32488361,  2.        , -0.61540483, -0.58295264],
       [-2.44526354,  2.        ,  2.        , -1.73224649],
       [-0.34215509, -1.07049879, -0.28219591, -0.3031155 ]])
```

```python
result = []
for i in range(n):
    result.append(0)
elif cond1[i] and cond2[i]:
    result.append(1)
elif cond2[i]:
    result.append(2)
else:
    result.append(3)

np.where(cond1 & cond2,0,np.where(cond1,1,np.where(cond2,2,3)))
```



### mean/sum/dumsun/cumprod

```python
arr = np.random.randn(5,4) # 正态分布的数据
arr.mean()
>>>-0.08429328344159606

np.mean(arr)
>>>-0.08429328344159606

arr.sum()
>>>-1.6858656688319213

arr.mean(axis=1)
>>>array([-0.51894274, -0.0234353 , -0.89300257,  0.34560603,  0.66830816])

arr.sum(0)
>>>array([-2.6684326 ,  2.88438813, -2.50622243,  0.60440123])

arr = np.array([[0,1,2],[3,4,5],[6,7,8]])
arr.cumsum(0)
>>>array([[ 0,  1,  2],
       [ 3,  5,  7],
       [ 9, 12, 15]])

arr.cumsum(0)
>>>array([[ 0,  1,  2],
       [ 3,  5,  7],
       [ 9, 12, 15]])

arr.cumprod(1)
>>>array([[  0,   0,   0],
       [  3,  12,  60],
       [  6,  42, 336]])
```

### 排序

```python
import numpy as np
arr = np.random.randn(8)
arr
>>>array([-2.49824734, -0.40004712, -0.87554657,  0.31454533,  1.8278497 ,
        0.52513878,  0.17799299,  0.83374211])

arr.sort()
arr
>>>array([-2.49824734, -0.87554657, -0.40004712,  0.17799299,  0.31454533,
        0.52513878,  0.83374211,  1.8278497 ])

arr = np.random.randn(5,3)
arr
>>>array([[-0.16565657, -0.15335212, -2.03631295],
       [ 1.14215426, -0.50757584,  1.84955603],
       [ 0.22922315, -1.29812042,  0.94843952],
       [ 1.27910595, -0.52182487,  0.88433111],
       [-1.38551781,  0.46411351, -0.698081  ]])

arr.sort(1)
arr
>>>array([[-2.03631295, -0.16565657, -0.15335212],
       [-0.50757584,  1.14215426,  1.84955603],
       [-1.29812042,  0.22922315,  0.94843952],
       [-0.52182487,  0.88433111,  1.27910595],
       [-1.38551781, -0.698081  ,  0.46411351]])
```

### 唯一化以及其他的集合逻辑

```python
names = np.array(['Bob','Joe','Will','Bob','Will','Joe','Joe'])
np.unique(names)
>>>array(['Bob', 'Joe', 'Will'], dtype='<U4')

ints = np.array([3,3,3,2,2,1,1,4,4])
np.unique(ints)
>>>array([1, 2, 3, 4])

values = np.array([6,0,0,3,2,5,6])
np.in1d(values,[2,3,6])
>>>array([ True, False, False,  True,  True, False,  True])
```

### 把数组以二进制格式保存到磁盘

- np.save/np.load以未压缩的原始二进制格式保存在扩展名为.npy的文件中

```python
arr = np.arange(10)
np.save('some_array',arr)
np.load('some_array.npy')
>>>array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
```

- np.savez可以把多个数组保存在一个压缩文件中。传入关键字参数即可

```python
np.savez('array_archive.npy',a=arr,b=arr)
arch = np.load('array_archive.npy')
arch['b']
>>>array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
```

### 存取文本文件

```python
arr = np.loadtxt('array_ex.txt',delimiter=',')
```

### 线性代数

```python
x = np.array([[1.,2.,3.],[4.,5.,6.]])
y = np.array([[6.,23.],[-1,7],[8,9]])
x
>>>array([[1., 2., 3.],
       [4., 5., 6.]])

y
>>>array([[ 6., 23.],
       [-1.,  7.],
       [ 8.,  9.]])

x.dot(y)
>>>array([[ 28.,  64.],
       [ 67., 181.]])

np.dot(x,np.ones(3))
>>>array([ 6., 15.])
```

- inv矩阵的逆
- qr计算QR分解
- svd 奇异值分解

```python
from numpy.linalg import inv,qr
X = np.random.randn(5,5)

mat = X.T.dot(X)
inv(mat)
>>>array([[ 1.68957798, -0.56519392, -0.6261379 , -0.07739239,  0.09259013],
       [-0.56519392,  0.50813013,  0.3531815 , -0.09610859, -0.06405307],
       [-0.6261379 ,  0.3531815 ,  0.78404704, -0.01311374, -0.0536648 ],
       [-0.07739239, -0.09610859, -0.01311374,  0.14822737,  0.04094803],
       [ 0.09259013, -0.06405307, -0.0536648 ,  0.04094803,  0.07835785]])

mat.dot(inv(mat))
>>>array([[ 1.00000000e+00,  2.64279123e-16,  7.46906091e-17,
        -2.24492372e-16, -4.56992592e-17],
       [ 3.89179844e-16,  1.00000000e+00,  1.78876973e-16,
         3.20488120e-17,  4.78503947e-17],
       [ 3.34866499e-16, -1.65330818e-16,  1.00000000e+00,
        -7.07253057e-17,  4.37442065e-17],
       [ 4.87962094e-16,  2.43383388e-16,  6.81721589e-17,
         1.00000000e+00, -1.90874904e-17],
       [-5.50879123e-16,  1.32100786e-16,  5.33569680e-17,
         1.42422241e-16,  1.00000000e+00]])

q,r = qr(mat)
r
>>>array([[ -3.28323491,  -5.97650399,   0.4567477 , -12.97923559,
         10.98741058],
       [  0.        ,  -3.54877343,   1.68726471,  -0.65749768,
         -7.67459559],
       [  0.        ,   0.        ,  -1.63842346,   2.25516174,
         -9.79758725],
       [  0.        ,   0.        ,   0.        ,  -5.2998246 ,
          2.03451325],
       [  0.        ,   0.        ,   0.        ,   0.        ,
          6.54107258]])

```

### 随机数生成

```python
import numpy as np
samples = np.random.normal(size=(4,4)) # 标准正态分布
samples
>>>array([[ 0.36362053,  0.89085972,  0.22788897, -0.81705269],
       [-1.51958734, -0.3640249 ,  0.89746583,  0.15960883],
       [-0.36920307, -0.75823035, -0.53177187, -2.15738747],
       [ 1.12166099,  0.72099335,  0.10810312,  1.52644148]])

from random import normalvariate
N = 1000000

%timeit samples = [normalvariate(0,1) for _ in range(N)]
>>>999 ms ± 168 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)

%timeit np.random.normal(size=N)
>>>37.6 ms ± 11.8 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)
```