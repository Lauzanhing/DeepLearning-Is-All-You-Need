## using声明

```cpp
#include<iostream>
using std::cin;

int main()
{
    int i;
    cin >> i;
    cout << i; // illegal
    return 0;
}
```



## string定义和初始化

```cpp
string s1; // 默认初始化/空字符串
string s2 = s1; // s2是s1的副本
string s3 = "hiya"; // s3是该字符串字面值的副本
string s4(10,'c'); // s4是cccccccccc
```





## 直接初始化和拷贝初始化

```cpp
string s5 = "hiya"; //拷贝
string s6("hiya"); //直接
string s7(10,'c'); //直接  
```





## getline读取一整行

```cpp
int main()
{
    string line;
    while(getline(cin,line))
        cout << line << endl;
    return 0;
}
```

```cpp
while(getline(cin,line))
    if(!line.empty())
        cout << line << endl;

while(getline(cin,line))
    if(line.size() > 80)
        cout << line << endl;
```





## 处理string对象中的字符

```cpp
string str('some string');
for(auto c : str)
    cout << c <<endl;
```

```cpp
string s("Hello World!!!");
decltype(s.size()) punct_cnt = 0;
for (auto c : s)
    if(ispunct(c))
        ++punct_cnt;
cout << punct_cnt << endl;
```

\>>> 3

```cpp
string s("Hello world!!!");
for (auto &c : s)
    c = toupper(c);
cout << s << endl;
```

\>>> HELLO WORLD!!!

```cpp
for(decltype(s.size()) index = 0; index != s.size() && !isspace(s[index]); ++index)
    s[index] = toupper(s[index]);
```

\>>> SOME string



## 标准库类型vector

```cpp
vector<int> ivec; // ivec保存int类型对象
vector<Sales_item> Sales_vec; // 保存Sales_item类型的对象
vector<vector<string>> file; // 该向量的元素是vector对象
```



## 定义和初始化vector对象

```cpp
vector<int> ivec;
vector<int> ivec2(ivec); //把ivec的元素拷贝给ivec2 
vector<int> ivec3 = ivec; //把ivec的元素拷贝给ivec3
vector<string> svec(ivec2); // 错误
```



## 列表初始化vector对象

```cpp
vector<string> v1{"a","an","the"}; //列表初始化
vector<string> v2("a","an","the"); //错误

vector<int> ivec(10,-1); //10个int类型元素,每个都是-1
vector<int> svec(10,"hi!");

vector<int> ivec(10);  //10个0
vector<string> svec(10); // 10个空string对象
```



## 列表初始值还是元素数量

```cpp
vector<int> v1(10); // v1有10个0
vector<int> v1{10}; // v2有一个元素:10

vector<int> v3(10,1); //10个1
vector<int> v4{10,1}; //两个元素10,2
```





## 向vector对象添加元素

```cpp
vector<int> v2;
for(int i = 0; i != 100; ++i)
    v2.push_back(i);
```

```cpp
string word;
vector<string> text;
while(cin >> word)
{
    text.push_back(word);
}
```

```cpp
vector<int> v{1,2,3,4,5,6,7,8,9};
for(auto &i : v)
    i *= i;
for(auto i : v)
    cout << i << " ";
cout << endl;
```



## 迭代器

```cpp
string s("some string");
if(s.begin() != s.end())
{
    auto it = s.begin();
    *it = toupper(*it);
}
```

```cpp
vector<int>::iterator it; //it可以读写vector<int>的元素
string::iterator it2; // it2能读写string对象中的字符

vector<int>::const_iterator it3; //it3只能读元素
string::const_iterator it4; //it4只能读字符
```

```cpp
vector<int> v;
const vector<int> cv;
auto it1 = v.begin(); //类型是vector<int>::iterator
auto it2 = cv.begin(); //类型是vector<int>::const_iterator

// c++11新标准 cbegin cend
auto it3 = v.cbegin(); //类型是vector<int>::const_iterator
```



## 结合解引用和成员访问操作

```cpp
(*it).empty() //解引用it,然后调用结果对象的empty成员
```

- 箭头运算符 ->也是解引用

```cpp
for(auto it = text.cbegin(); it != text.cend() && !it->empty(); ++it)
    cout << *it << endl;
```





## 定义和初始化内置数组

- 维度必须是常量表达式

```cpp
unsigned cnt = 43; //不是常量表达式
constexpr unsigned se = 43; //常量表达式
int arr[10]; // 对
int *parr[sz]; // 对
string bad[cnt]; // 错误
string strs[get_size()]; // get_size是constexpr就正确 不然错误
```



## 显式初始化数组元素

```cpp
const unsigned sz = 3; 
int ia1[sz] = {0,1,2};
int a2[] = {0,1,2};
int a3[5] = {0,1,2};
string a4[3] = {'hi','bye'};
int a5[2] = {0,1,2}; // illegal
```





## 字符数组的特殊性

```cpp
char a1[] = {'C','+','+'}; //没有空字符
char a2[] = {'C','+','+','\0'}; // 显式空字符
char a3[] = "C++"; // 自动添加表示字符串结束的空字符
const char a4[6] = 'Daniel'; // 错误 放不下空字符
```

- 不允许拷贝和赋值

```cpp
int a[] = {0,1,2};
int a2[] = a; // illegal
a2 = a; // illegal
```

```cpp
int *ptrs[10]; // ptrs是含有10个整型指针的数组
int &refs[10] = /* ?*/; // 错误,不存在引用的数组
int (*parray)[10] = &arr; // Parray指向一个含有10个整数的数组
int (&arrRef)[10] = arr; // arrRef引用一个含有10个整数的数组

int *(&arry)[10] = ptrs; // arry是引用,该数组有10个指针
```



## 指针和数组

```cpp
string nums[] = {"one","two","three"}; //数组的元素是string对象
string *p = &nums[0]; // p指向nums的第一个元素

string *p2 = nums; // 等于p2 = &nums[0]
```

```cpp
int ia[] = {0,1,2,3,4,5,6,7,8};
auto ia2(ia); // ia2是一个整型指针,指向ia的第一个元素
ia2 = 42; // illegal
auto ia2(&ia[0]); // 显然ia2的类型是int*
```

```cpp
decltype(ia) ia3 = {0,1,2,3,4,5,6,7,8,9};
ia3 = p; // 不能用整型指针给数组赋值
ia3[4] = i; // 把i的值赋给ia3的一个元素
```





## 指针也是迭代器

```cpp
int arr[] = {0,1,2,3,4,5,6,7,8,9};
int *p = arr;
++p; // p指向arr[1]
```



## 标准库函数begin和end

```cpp
int ia[] = {0,1,2,3,4,5,6,7,8,9};
int *beg = begin(ia);
int *last = end(ia); // 指向arr尾元素的下一位置的指针
```



## 指针运算

```cpp
// size_t 用在数组下标
constexpr size_t sz = 5;
int arr[sz] = {1,2,3,4,5};
int *ip = arr; // 等价于int *ip = &arr[0]
int *ip2 = ip + 4; // ip2指向arr的尾元素
```

```cpp
auto n = end(arr) - begin(arr);
// ptridff_t 两个指针相减的类型
```

```cpp
int *b = arr, *e = arr + sz;
while(b < e)
{
    ++b;
}
```



## 解引用和指针运算的交互

```cpp
int ia[] = {0,2,4,6,8};
int last = *(ia + 4); // 值为8
int last = *ia+4; / 值为ia[0]+4
```



## 下标和指针

```cpp
int ia[] = {0,2,4,6,8};
int i = ia[2]; 
int *p = ia;
i = *(p+2);

int *p = &ia[2];
int j = p[1];
int k = p[-2];
```



## 比较字符串

```cpp
string s1 = "A string example";
string s2 = "A different string";
if(s1<s2) // false, s1 > s2
```

- 使用数组实际上是用指向数组首元素的指针

```cpp
const char ca1[] = "A string example";
const char ca2[] = "A different string";
if(ca1<ca2) // 试图比较两个无关地址
```



## 混用string对象和c风格字符串

```cpp
string s("Hello World");
char *str = s; // wrong 不能用string对象初始化char*
const char *str = s.c_str();
```



## 使用数组初始化vector对象

```cpp
int int_arr[] = {0,1,2,3,4,5};
vector<int> ivec(begin(int_arr),end(int_arr));
vector<int> subVec(int_arr+1,int_arr+4);
```



## 多维数组

```cpp
int ia[3][4];
int arr[10][20][30] = {0};

int ia[3][4] = {
    {0,1,2,3},
    {4,5,6,7},
    {8,9,10,11}
};
int ia[3][4] = {0,1,2,3,4,5,6,7,8,9,10,11};

int ia[3][4] = {{ 0 },{ 4 },{ 8 }};
```



## 多维数组的下标引用

```cpp
ia[2][3] = arr[0][0][0];
int (&row)[4] = ia[1]; // 把row绑定到ia的第二个4元素数组上
```

```cpp
constexpr size_t rowCnt = 3,colCnt=4;
int ia[rowCnt][colCnt]; // 12个未初始化的元素
for(size_t i = 0; i != rowCnt; ++i)
{
    for(size_t j = 0; j != colCnt; ++j)
    {
        ia[i][j] = i * colCnt + j;
    }
}
```



## 使用范围for语句处理多维数组

```cpp
size_t cnt = 0;
for (auto &row : ia)
    for(autp &col : row)
    {
        col = cnt;
        ++cnt;
    }
```



## 指针和多维数组

```cpp
int ia[3][4];
int (*p)[4] = ia; // p指向含有4个整数的数组
p = &ia[2]; // p指向ia的尾元素

int *ip[4]; // 整型指针的数组
int (*ip)[4]; // 指向含有4个整数的数组
```

```cpp
for(auto p = begin(ia); p != end(ia); ++p)
{
    for(auto q = begin(*p); q != end(*p); ++q)
        cout << *q << ' ';
    cout << endl;
}
```

